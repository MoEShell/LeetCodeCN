## k个一组翻转链表
### 思考
链表有个特性：不能随机存取。对于单链表想要操作某个结点必须找到该结点的前一个结点。对于k个一组翻转，也就是说有 k/2 个结点顺序操作，k/2 个结点逆序操作，要找到前一个结点非常繁琐。所以考虑用栈来储存结点，利用栈“先进后出”的特性来翻转。

另一个细节，被操作的链表是没有头结点的链表，在翻转后原来的首个节点将不再是首个结点。所以要加一个头结点，否则将会丢失一部分结点。

特殊情况：如果读入的链表为 null，不处理，直接返回。

### 算法
 0. 预处理：头结点 list.next 指向 head，头指针 point 和尾指针 tail 指向 list。建立栈 buffer
 1. 尾指针 tail 遍历 k 个结点，如果在过程中出现 null 表现链表遍历结束，返回 list.next
 2. 建立临时指针 tmp 记录 tail.next 
 3. 读取 point.next 压入栈中，point.next 指向 point.next。重复直到 point.next 指向 tmp
 4. 出栈构建链表，point.next 指向出栈的元素，point.next 指向 point.next。重复直到栈空
 5. 重复步骤 1～5
 
### 要点
在压栈出栈过程中结点的 next 指针指向会错乱，要依次整理，还要记录关键结点（_**i.e.**_ tail.next）防止数据丢失 
